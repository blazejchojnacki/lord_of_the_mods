# 024-07-29-30
import os
from shutil import copy2, move, Error
# import shutil
from tkinter.filedialog import askopenfilename, askdirectory
from tkinter.simpledialog import askstring
from tkinter.messagebox import askokcancel
from os import path, listdir
from datetime import datetime
import xxhash
from glob import glob

from settings_editor import read_settings, MODULES_LIBRARY, BACKUP_FOLDER, MODULE_TEMPLATE, LOG_PATH, EXCEPTION_FOLDERS
from constants import PROGRAM_DIRECTORY, PROGRAM_NAME, ModuleError, UnderTestWarning

settings = read_settings()
exception_paths = ['>no_path<', 'unsorted', PROGRAM_DIRECTORY, settings['backup_folder'], settings['modules_library']]

TRANSFER_TYPES = [
    'move',
    'copy',
    'delete',
]
DEFINITION_NAME = '_definition.ini'
DEFINITION_CLASSES = ['Version', 'Module', 'Template']
DEFINITION_DICT = {
    'path': '',
    'class': '',
    'comment': "// do not edit this file by hand. Use the 'edit definition' option in the application\n",
    'game': '',
    'name': '',
    'active': False,
    'progress': '',
    'ancestor': '',
    'heir': '',
    'description': '',
    'changes': {}
}


# 024-08-06
class Definition(dict):
    def __init__(self):
        super().__init__()
        for key in DEFINITION_DICT:
            # if DEFINITION_DICT[key] is dict:
            #     self[key] = {}
            # else:
            #     self[key] = DEFINITION_DICT[key]
            try:
                self[key] = DEFINITION_DICT[key].copy()
            except AttributeError:
                self[key] = DEFINITION_DICT[key]

    def edit(self, **key_args):
        return edit_definition(self, **key_args)

    def reload(self):
        if self['class'] == DEFINITION_CLASSES[0]:
            module_reverse(mod_name=self['name'], transfer='move')
            module_attach(self['path'])
        elif self['class'] == DEFINITION_CLASSES[1]:
            module_reverse(mod_name=self['name'], transfer='delete')
            module_attach(self['path'])


# 024-08-06
def write_definition(definition_dict=None, module_directory=None, return_type='dict', **key_args):
    if module_directory is None:
        if definition_dict is None:
            module_directory = askdirectory(title=f'{PROGRAM_NAME}: select the directory to define as a module',
                                            initialdir=MODULES_LIBRARY)
            if not module_directory:
                raise ModuleError('initiate_version_definition error: directory not selected')
    if module_directory is not None:
        version_name = module_directory.split('/')[-1]
    elif definition_dict is not None:
        version_name = definition_dict['name']
        module_directory = definition_dict['path']
    if not path.isdir(module_directory):
        return write_definition(return_type=return_type, **key_args)
    if definition_dict is None:
        if path.exists(f'{module_directory}/{DEFINITION_NAME}'):
            definition_dict = read_definition(module_path=f'{module_directory}')
            if 'dict' in return_type:
                return definition_dict
            elif 'text' in return_type:
                pass
        else:
            definition_dict = Definition()
    else:
        pass
    automatic_definition = definition_dict['comment']
    if 'class' in key_args:
        automatic_definition += f"{key_args['class']} {module_directory.split('/')[-1]}\n"
    elif definition_dict['class'] and definition_dict['name']:
        automatic_definition += f"{definition_dict['class']} {definition_dict['name']}\n"
    else:
        automatic_definition += f"{DEFINITION_CLASSES[1]} {module_directory.split('/')[-1]}\n"
    if not definition_dict['game']:
        for version_folder in listdir(module_directory):
            if path.isdir(f'{MODULES_LIBRARY}/{version_folder}') and not definition_dict['game']:
                definition_dict['game'] += version_folder
            elif path.isdir(f'{MODULES_LIBRARY}/{version_folder}') and definition_dict['game']:
                definition_dict['game'] += f', {version_folder}'
            if not definition_dict['game']:
                definition_dict['game'] = version_name.split('-')[0]
    if not definition_dict['path'] and module_directory:
        definition_dict['path'] = module_directory
    if not definition_dict['name'] and module_directory:
        definition_dict['name'] = module_directory.split('/')[-1]
    if 'ancestor' in key_args:
        definition_dict['ancestor'] = key_args['ancestor']
    if 'heir' in key_args:
        definition_dict['heir'] = key_args['heir']
    for key in DEFINITION_DICT:
        if key == 'comment' or key == 'class':
            pass
        elif key == 'changes':
            new_changes = ''
            if path.exists(f"{module_directory}/comparison_{version_name}.txt"):
                with open(f"{module_directory}/comparison_{version_name}.txt") as comparison_file:
                    comparison_lines = comparison_file.readlines()
                    for line in comparison_lines:
                        full_path, value = line.strip().split('\t')
                        if value != 'unchanged':
                            new_changes += f'\t\t{line}'
            automatic_definition += f'\t{key}\n{new_changes}\tEnd\n'
        else:
            automatic_definition += f"\t{key} = {definition_dict[key]}\n"
    automatic_definition += 'End'
    if 'save' in return_type:
        with open(f'{module_directory}/{DEFINITION_NAME}', 'w') as definition_buffer:
            definition_buffer.write(automatic_definition)
    if 'text' in return_type:
        return automatic_definition
    elif 'dict' in return_type:
        return definition_dict
    # automatic_definition_dict = read_definition(definition_text=automatic_definition)
    # if automatic_definition_dict is not None:
    #     automatic_definition_dict['path'] = f'{module_directory}'
    # return automatic_definition_dict
    # else:
    #     if return_type == 'text':
    #
    #     return read_definition(module_path=f'{module_directory}')
    #     # with open(f'{definition_directory}/{DEFINITION_NAME}', 'r') as definition_buffer:
    #     #     definition_content = definition_buffer.read()
    #     # definition_changeless = definition_content[:definition_content.index('changes') + len('changes')]
    #     # version_name = definition_directory.split('/')[-1]
    #     # new_changes = ''
    #     # if path.exists(f"{definition_directory}/comparison_{version_name}.txt"):
    #     #     with open(f"{definition_directory}/comparison_{version_name}.txt") as comparison_file:
    #     #         comparison_lines = comparison_file.readlines()
    #     #         for line in comparison_lines:
    #     #             full_path, value = line.strip().split('\t')
    #     #             if value != 'unchanged':
    #     #                 new_changes += f'\t\t{line}'
    #     # updated_definition = definition_changeless + new_changes + definition_content[definition_content.index('\tEnd')]
    #     # if updated_definition != definition_content:
    #     #     with open(f'{definition_directory}/{DEFINITION_NAME}', 'w') as definition_buffer:
    #     #         definition_buffer.write(updated_definition)


# 024-08-06
def read_definition(definition_dict=None, module_path=None, definition_text=None):
    definition_lines = None
    if definition_text is None:
        if definition_dict is Definition or definition_dict is dict:
            module_path = definition_dict['path']
        elif module_path is None or not module_path:
            definition_dict = Definition()
            module_path = askdirectory(title='select the module directory', initialdir=MODULES_LIBRARY)
            if not module_path:
                raise ModuleError('read_definition error: module not selected')
        if definition_dict is not None and path.exists(f'{module_path}/{DEFINITION_NAME}'):
            definition_dict['path'] = module_path
        if path.exists(f'{module_path}/{DEFINITION_NAME}'):
            with open(f'{module_path}/{DEFINITION_NAME}') as definition_buffer:
                definition_lines = definition_buffer.readlines()
    elif isinstance(definition_text, str):
        definition_lines = definition_text.split('\n')
    if definition_dict is None:
        definition_dict = Definition()
    if definition_lines:
        for line in definition_lines:
            if line.startswith('//'):
                definition_dict['comment'] = f'{line.strip()}\n'
            elif ' = ' in line.strip():
                parameter, value = line.strip().split(' = ')
                if parameter in DEFINITION_DICT:
                    if value == 'True':
                        definition_dict[parameter] = True
                    elif value == 'False':
                        definition_dict[parameter] = False
                    else:
                        definition_dict[parameter] = value
            elif '\t' in line.strip():
                # try:
                file_path, vector = line.strip().split('\t')
                definition_dict['changes'][file_path] = vector
                # except:
                #     pass
            elif line.split()[0] in DEFINITION_CLASSES:
                definition_dict['class'] = line.split()[0]
    else:
        do_initiate = askokcancel(
            title='Lord of the Mods',
            message='the selected folder seems to have no definition.\n\tdo you wish to initiate an automatic one?\n'
                    f'{module_path}'
        )
        if do_initiate:
            definition_dict = write_definition(module_directory=module_path, return_type='dict save')
    return definition_dict


# 024-08-06
def edit_definition(definition_dict=None, module_path=None, **key_args):
    if definition_dict is None:
        if module_path is None:
            module_path = askdirectory(title=f'{PROGRAM_NAME}:', initialdir=MODULES_LIBRARY)
        if module_path:
            definition_dict = read_definition(module_path=module_path)
        if not definition_dict:  # not path.exists(f'{module_path}/{DEFINITION_NAME}'):
            raise ModuleError('edit_definition error: definition missing')
    for key in key_args:
        if key in DEFINITION_DICT:
            if key == 'name':
                list_modules = modules_filter(strict=False)
                for module_name in list_modules:
                    if key_args['name'] == module_name:
                        print('edit_definition error: name already in use')
                        return
                    module_definition = read_definition(module_path=f'{MODULES_LIBRARY}/{module_name}')
                    if definition_dict['name'] in module_definition['ancestor']:
                        edit_definition(
                            module_definition,
                            ancestor=module_definition['ancestor'].replace(definition_dict['name'], key_args['name'])
                        )
                    if definition_dict['name'] in module_definition['heir']:
                        edit_definition(
                            module_definition,
                            heir=module_definition['heir'].replace(definition_dict['name'], key_args['name'])
                        )
            definition_dict[key] = key_args[key]
        else:
            print(f'key {key} not recognized')
    return write_definition(definition_dict, return_type='dict save')


# 024-07-30
def hash_file(file):
    with open(file, 'rb') as file_pointer:
        file_content = file_pointer.read()
    hashed_content = xxhash.xxh128(file_content).hexdigest()
    return hashed_content


# 024-07-29
def hash_directory(file_or_folder, path_to_omit=''):
    output = ''
    if path.isfile(file_or_folder):
        if path_to_omit:
            path_to_register = file_or_folder[file_or_folder.index(path_to_omit) + len(path_to_omit) + 1:]
        else:
            path_to_register = file_or_folder
        output += f'{path_to_register}\t{hash_file(file_or_folder)}\n'
    elif path.isdir(file_or_folder):
        next_directory = listdir(file_or_folder)
        for next_file_or_folder in next_directory:
            output += hash_directory(f'{file_or_folder}/{next_file_or_folder}', path_to_omit=path_to_omit)
    return output


def get_last_snapshot_id(snapshot_list, key='file_snapshot_'):
    suffix = ''
    try:
        while not suffix.isnumeric():
            last_snapshot = max(snapshot_list, key=os.path.getctime)
            snapshot_list.remove(last_snapshot)
            suffix = last_snapshot[last_snapshot.index(key) + len(key):last_snapshot.index('.txt')]
        counter = str(int(suffix) + 1)
    except ValueError:
        counter = askstring(title='LordOfTheMods', prompt='Please give a name to the new file')
    return counter


# 024-07-30
def snapshot_make(game_paths=None, multiple=False, return_type='path'):
    if game_paths is None:
        game_paths = ['>no_path<']
    game_snapshot = str(datetime.now()) + '\n'
    # modules_paths = listdir(settings['installation_path'])
    # modules_paths = listdir(path='O:')
    # modules_paths = ['RotWK']  # 'BfME2',
    path_to_omit = ''
    for game_path in game_paths:
        if game_path == '>no_path<':  # settings['installation_path']
            game_full_path = askdirectory(initialdir=f"{settings['installation_path']}/",
                                          title='Lord of the Mods: select game directory to take a snapshot of')
            if game_full_path:
                if MODULES_LIBRARY in game_full_path:
                    path_to_omit += '/'.join(game_full_path.split('/')[:MODULES_LIBRARY.count('/') + 2])
                path_to_omit_locally = settings['installation_path']
                game_path = game_full_path[game_full_path.index(path_to_omit_locally) + len(path_to_omit_locally) + 1:]
                game_paths[game_paths.index('>no_path<')] = game_path
                if multiple:
                    game_paths.append('>no_path<')
            elif len(game_paths) == 0:
                print('make_snapshot error: directory not selected')
                return
        mod_dir = f"{settings['installation_path']}/{game_path}"
        if not path.isdir(mod_dir) or game_path in exception_paths:
            game_paths.remove(game_path)
    for game_path in game_paths:
        game_snapshot += hash_directory(f"{settings['installation_path']}/{game_path}", path_to_omit=path_to_omit)
    if return_type == 'text':
        print('make_snapshot successful')
        return game_snapshot
    counter = 1
    if not path.exists('./snapshots'):
        os.mkdir('./snapshots')
    elif path.exists(f'./snapshots/file_snapshot_1.txt'):
        snapshot_list = glob(f'./snapshots/file_snapshot_*.txt')
        counter = get_last_snapshot_id(snapshot_list)
    with open(f"./snapshots/file_snapshot_{counter}.txt", 'w') as snapshot_buffer:
        snapshot_buffer.write(game_snapshot)
    print('snapshot_make successfully saved in file')
    return f"./snapshots/file_snapshot_{counter}.txt"


# 024-07-30
def snapshot_compare(snap_anterior=None, snap_posterior=None, return_type='path'):
    content_anterior = []
    content_posterior = []
    lines = []
    if snap_anterior is None:
        snap_anterior = askopenfilename(title=f'{PROGRAM_NAME}: choose the base snapshot to compare with',
                                        initialdir='./snapshots')
        if not snap_anterior:
            raise ModuleError('snapshot_compare error: no snapshot selected')
    elif snap_anterior is list:
        content_anterior = snap_anterior
    if path.isfile(snap_anterior):
        with open(snap_anterior) as file_anterior:
            content_anterior = file_anterior.readlines()
    if snap_posterior is None:
        snap_posterior = askopenfilename(title=f'{PROGRAM_NAME}: choose the second snapshot to compare',
                                         initialdir='./snapshots')
        if not snap_posterior:
            raise ModuleError('snapshot_compare error: no snapshot selected')
    elif snap_posterior is list:
        content_posterior = snap_posterior
    if path.isfile(snap_posterior):
        with open(snap_posterior) as file_posterior:
            content_posterior = file_posterior.readlines()
    dict_anterior = {}
    dict_posterior = {}
    for line_anterior in content_anterior[1:]:
        if line_anterior.startswith('20'):
            continue
        elif '\t' in line_anterior:
            name_anterior, code_anterior = line_anterior.split('\t')
            dict_anterior[name_anterior] = code_anterior
    for line_posterior in content_posterior[1:]:
        if line_posterior.startswith('20'):
            continue
        elif '\t' in line_posterior:
            name_posterior, code_posterior = line_posterior.split('\t')
            dict_posterior[name_posterior] = code_posterior
    for key_name_anterior in dict_anterior:
        try:
            if dict_anterior[key_name_anterior] == dict_posterior[key_name_anterior]:
                lines.append(key_name_anterior + f'\tunchanged\n')
            else:
                lines.append(key_name_anterior + f'\tdifferent\n')
        except KeyError:
            lines.append(key_name_anterior + f'\tremoved\n')
    for key_name_posterior in dict_posterior:
        if key_name_posterior not in dict_anterior:
            lines.append(key_name_posterior + f'\tnew\n')
    index = 1
    if return_type == 'lines':
        return lines
    else:
        if not path.exists('./snapshots'):
            os.mkdir('./snapshots')
        elif path.exists(f'./snapshots/comparison_1.txt'):
            comparison_list = glob(f'./snapshots/comparison_*.txt')
            index = get_last_snapshot_id(comparison_list, 'comparison_')
        with open(f'./snapshots/comparison_{index}.txt', 'w') as last_comparison:
            last_comparison.writelines(lines)
        return f'./snapshots/comparison_{index}.txt'


test_previous_src = ''
test_previous_dst = ''
test_previous_type = ''
print_colors = {
    'i': '\033[96m',
    'w': '\033[93m',
    'e': '\033[91m',
    'end': '\033[0m',
}


def test_transfer(src, dst='', transfer='copy'):
    global test_previous_src, test_previous_dst, test_previous_type
    if TEST:
        if path.exists(src):
            if transfer == 'delete':
                print(f'for deletion: {src}')
                if not path.isfile(f"{dst}/{src.split('/')[-1]}"):
                    print(f"{print_colors['w']}warning:{print_colors['end']} original absent {dst}/{src.split('/')[-1]}")
            else:
                print(f'source: {src}')
        else:
            print(f"{print_colors['e']}error:{print_colors['end']} source absent {src}")
        if dst and transfer != 'delete':
            if path.exists(dst):
                if path.isfile(f"{dst}/{src.split('/')[-1]}") and test_previous_src == f"{dst}/{src.split('/')[-1]}":
                    if test_previous_type == 'delete':
                        print(f"{print_colors['i']}information:{print_colors['end']} destination {test_previous_src} deleted")
                    elif test_previous_type == 'move':
                        print(f"destination: {dst} (correct)")
                    else:
                        print(f"{print_colors['w']}warning:{print_colors['end']} destination present {dst}/{src.split('/')[-1]}")
                else:
                    print(f'destination: {dst}')
            else:
                print(f"{print_colors['e']}error:{print_colors['end']} destination absent {dst}")
    else:
        try:
            if transfer == 'copy':
                copy2(src, dst)
            elif transfer == 'move':
                move(src, dst)
            elif transfer == 'delete':
                os.remove(src)
        except Error as err:
            print(err)
        except FileNotFoundError as err:
            print(err)
    test_previous_src, test_previous_dst, test_previous_type = src, dst, transfer


def ensure_path_exists(file_path, check_path=''):
    if not check_path:
        check_path = '/'.join(file_path.split('/')[:-1])
    path_folders = file_path.split('/')
    file_path_part = ''
    for file_folder in path_folders[1:-1]:
        file_path_part += f'/{file_folder}'
        if not path.exists(f"{check_path}/{file_path_part}"):
            os.mkdir(f"{check_path}/{file_path_part}")


# 024-07-30
def module_reverse(mod_name='last_mod', transfer='copy', comparison_path=None, last_snapshot=None, check_type='definition'):
    comparison_lines = []
    if not path.isdir(f'{MODULES_LIBRARY}/{mod_name}'):
        os.mkdir(f'{MODULES_LIBRARY}/{mod_name}')
    module_directory = f'{MODULES_LIBRARY}/{mod_name}'
    if transfer == 'move' or transfer == 'delete':
        changes = module_detect_changes(module_directory=module_directory)
        if changes:
            raise ModuleError('module_reverse error: changes have been made to the module file')
            # TODO: if changes, propose to save them
    if path.isfile(f"{module_directory}/comparison_{mod_name}.txt"):
        comparison_path = f"{module_directory}/comparison_{mod_name}.txt"
    if comparison_path is None and not comparison_lines:
        if last_snapshot is None:
            selected_file = askopenfilename(title=f'{PROGRAM_NAME}: select a snapshot or a comparison file', initialdir='./snapshots')
            if selected_file.split('/')[-1].startswith('comparison_'):
                comparison_path = selected_file
            elif selected_file.split('/')[-1].startswith('file_snapshot_'):
                last_snapshot = selected_file
        if last_snapshot:
            new_snapshot = snapshot_make(return_type='text')
            comparison_lines = snapshot_compare(last_snapshot, new_snapshot, return_type='lines')
        if not comparison_path:
            raise ModuleError('module_reverse error: comparison missing')
    if path.isfile(comparison_path):
        with open(comparison_path) as comparison_file:
            comparison_lines = comparison_file.readlines()
    if not comparison_lines:
        raise ModuleError('module_reverse error: comparison missing')
    if check_type == 'snapshot':
        # TODO: verify prerequisites by making a snapshot and comparing it
        pass
    elif check_type == 'definition':
        if path.exists(f'{module_directory}/{DEFINITION_NAME}'):
            definition_dict = read_definition(module_path=module_directory)
            if definition_dict['heir']:
                heir_directory = f"{'/'.join(module_directory.split('/')[:-1])}/{definition_dict['heir']}"
                if path.exists(f'{heir_directory}/{DEFINITION_NAME}'):
                    heir_definition_dict = read_definition(module_path=heir_directory)
                    if heir_definition_dict['active']:
                        raise ModuleError(f"module_reverse error: heir module {definition_dict['heir']} still active")
    for line in comparison_lines:
        path_start = len(settings['installation_path'].split('/'))
        file_path, value = line.strip().split('\t')
        file_path_module = f"{MODULES_LIBRARY}/{mod_name}/{'/'.join(file_path.split('/')[path_start:-1])}"
        file_path_archive = f"{BACKUP_FOLDER}/{mod_name}/{'/'.join(file_path.split('/')[path_start:])}"
        if value == 'unchanged':
            pass
        elif value == 'different':
            if transfer in TRANSFER_TYPES:  # transfer == 'copy' or transfer == 'move':
                ensure_path_exists(file_path, f'{MODULES_LIBRARY}/{mod_name}')
                test_transfer(file_path, file_path_module, transfer)
            if transfer == 'move' or transfer == 'delete':
                ensure_path_exists(file_path, f'{BACKUP_FOLDER}/{mod_name}')
                test_transfer(file_path_archive, '/'.join(file_path.split('/')[:-1]), 'move')
        elif value == 'new':
            ensure_path_exists(file_path, f'{MODULES_LIBRARY}/{mod_name}')
            try:
                test_transfer(file_path, file_path_module, transfer)
            except FileExistsError:
                pass
        elif value == 'removed':
            if transfer == 'move' or transfer == 'delete':
                ensure_path_exists(file_path, f'{BACKUP_FOLDER}/{mod_name}')
                test_transfer(file_path_archive, '/'.join(file_path.split('/')[:-1]), 'move')
            else:
                pass
    if TEST:
        raise UnderTestWarning('under TEST phase: module_reverse not applied')
    return 'module_reverse successful'


# def test_move(src, dst):
#     if TEST:
#         if path.exists(src):
#             print(f'source: {src}')
#         else:
#             print(f'error: absent {src}')
#         if path.exists(dst):
#             print(f'destination: {dst}')
#             if path.isfile(f"{dst}/{src.split('/')[-1]}"):
#                 print(f"warning: present {dst}/{src.split('/')[-1]}")
#         else:
#             print(f'error: absent {dst}')
#     else:
#         try:
#             move(src, dst)
#         except Error as err:
#             print(err)
#         except FileNotFoundError as err:
#             print(err)


# 024-07-31
def module_attach(module_directory=None, check_type='definition'):
    transfer = 'move'
    if module_directory is None:
        module_directory = askdirectory(title=f'{PROGRAM_NAME}: select module directory', initialdir=MODULES_LIBRARY)
        if not module_directory:
            print('module_attach error: module directory missing')
            raise ModuleError('module_attach error: module directory missing')
            # return
    if check_type == 'snapshot':
        # TODO: verify prerequisites by making a snapshot and comparing it
        pass
    elif check_type == 'definition':
        if path.exists(f'{module_directory}/{DEFINITION_NAME}'):
            definition_dict = read_definition(module_path=module_directory)
            if definition_dict['class'] == DEFINITION_CLASSES[0]:
                transfer = 'move'
            elif definition_dict['class'] == DEFINITION_CLASSES[1]:
                transfer = 'copy'
            if definition_dict['ancestor']:
                ancestor_directory = f"{'/'.join(module_directory.split('/')[:-1])}/{definition_dict['ancestor']}"
                if path.exists(f'{ancestor_directory}/{DEFINITION_NAME}'):
                    ancestor_definition_dict = read_definition(module_path=ancestor_directory)
                    if not ancestor_definition_dict['active']:
                        err = f"attach_module error: ancestor module {definition_dict['ancestor']} not active"
                        raise ModuleError(err)
    mod_name = module_directory.split('/')[-1]
    if not path.exists(f'{BACKUP_FOLDER}/{mod_name}'):
        os.mkdir(f'{BACKUP_FOLDER}/{mod_name}')
    if path.exists(f"{module_directory}/comparison_{mod_name}.txt"):
        with open(f"{module_directory}/comparison_{mod_name}.txt") as comparison_buffer:
            comparison_lines = comparison_buffer.readlines()
        for line in comparison_lines:
            file_path, value = line.strip().split('\t')
            # file_name = file_path.split('/')[-1]
            path_start = len(settings['installation_path'].split('/'))
            file_path_archive = f"{BACKUP_FOLDER}/{mod_name}/{'/'.join(file_path.split('/')[path_start:-1])}"
            file_path_module = f"{MODULES_LIBRARY}/{mod_name}/{'/'.join(file_path.split('/')[path_start:])}"
            if value == 'unchanged':
                pass
            elif value == 'different':
                ensure_path_exists(file_path)
                ensure_path_exists(file_path, f'{BACKUP_FOLDER}/{mod_name}')
                test_transfer(file_path, file_path_archive, transfer)
                test_transfer(file_path_module, '/'.join(file_path.split('/')[:-1]), transfer)
            elif value == 'new':
                ensure_path_exists(file_path)
                test_transfer(file_path_module, '/'.join(file_path.split('/')[:-1]), transfer)
            elif value == 'removed':
                ensure_path_exists(file_path)
                test_transfer(file_path, file_path_archive, transfer)
    else:
        print('module_attach error: comparison missing')
        raise ModuleError('module_attach error: comparison missing')
    if TEST:
        raise UnderTestWarning('Test phase: module_attach not applied')
    print('module_attach successful')


def module_copy(new_name, template_directory=None):
    if template_directory is None:
        template_directory = MODULE_TEMPLATE
    all_modules = modules_filter(strict=False)
    if new_name in all_modules:
        raise ModuleError('module_copy error: name already in use')
    output = ''
    folders = []
    files = []
    game_folder = new_name.split('-')[0]
    items_list = os.listdir(template_directory)
    for item in items_list:
        if os.path.isdir(f'{template_directory}/{item}'):
            folders.append(f'{MODULES_LIBRARY}/{new_name}/{game_folder}/{item}')
            for next_item in os.listdir(f'{template_directory}/{item}'):
                items_list.append(f'{item}/{next_item}')
                if os.path.isdir(f'{template_directory}/{item}/{next_item}'):
                    folders.append(f'{MODULES_LIBRARY}/{new_name}/{game_folder}/{item}/{next_item}')
        elif os.path.isfile(f'{template_directory}/{item}'):
            files.append(item)
        else:
            print(f"module_control.module_copy() warning: item {item} is neither a file nor folder")
    for folder in folders:
        if not os.path.exists(folder):
            os.makedirs(folder)
            output += folder + '\n'
    for file in files:
        copied_file = f'{template_directory}/{file}'
        try:
            test_transfer(copied_file, f'{MODULES_LIBRARY}/{new_name}/{game_folder}/{file}', 'copy')
            output += f'{MODULES_LIBRARY}/{new_name}/{game_folder}/{file}\n'
        except FileNotFoundError:
            print('module_control.module_copy() warning: permission denied')
        except FileExistsError:
            print(f'module_control.module_copy() warning: FileNotFoundError')
        if file == DEFINITION_NAME:
            with open(f'{MODULES_LIBRARY}/{new_name}/{game_folder}/{file}', 'r') as read_file:
                read_lines = read_file.readlines()
                new_content = ''
            for line in read_lines:
                if 'name: ' in line:
                    new_content += f'name: {new_name}\n'
                else:
                    new_content += line
            with open(f'{MODULES_LIBRARY}/{new_name}/{game_folder}/{file}', 'w') as overwritten_file:
                overwritten_file.write(new_content)
    try:
        with open(f'{LOG_PATH}/mod_loaded.txt', 'a') as log_file:
            log_file.write(output + '\n')
    except FileNotFoundError:
        with open(f'{LOG_PATH}/mod_loaded.txt', 'w') as log_file:
            log_file.write(output + '\n')
    return output


# 024-08-06
def module_detect_changes(module_directory=None):
    changes = ''
    comparison_lines = []
    if module_directory is None:
        # selected_file = askopenfilename(title='Lord of the mods: select a snapshot or a comparison file',
        #                                 initialdir=module_directory)
        module_directory = askdirectory(title=f'{PROGRAM_NAME}: select a module directory', initialdir=MODULES_LIBRARY)
        if not module_directory:
            raise ModuleError('module_detect_changes error: no module selected')
        last_snapshot_path = f"{module_directory}/file_snapshot_{module_directory.split('/')[-1]}"
        if path.isfile(last_snapshot_path):
            new_snapshot = snapshot_make(return_type='text')
            comparison_lines = snapshot_compare(last_snapshot_path, new_snapshot, return_type='lines')
        if not comparison_lines:
            raise ModuleError('module_detect_changes error: no comparison')
    # TODO: check if files inside the module have changed
    for line in comparison_lines:
        if '\t' in line:
            file_path, value = line.strip().split('\t')
            if value == 'unchanged':
                pass
            elif value == 'different':
                changes += line
            elif value == 'new':
                changes += line
            elif value == 'removed':
                changes += line
        else:
            print(line)
    return changes


def modules_filter(game=None, return_type='names'):
    exceptions = EXCEPTION_FOLDERS
    if game is None:
        game = askdirectory(title=f'{PROGRAM_NAME}: select the game',
                            initialdir=f"{settings['installation_path']}/").split('/')[-1]
    game_modules_list = []
    # modules_names = listdir(MODULES_LIBRARY)
    modules_names = [_ for _ in listdir(MODULES_LIBRARY) if _ not in exceptions]
    if game == 'all':
        for module_name in modules_names:
            if return_type == 'names':
                game_modules_list.append(module_name)
            elif return_type == 'definitions':
                game_modules_list.append(read_definition(module_path=f'{MODULES_LIBRARY}/{module_name}').copy())
        return game_modules_list
    for module_name in modules_names:
        if path.exists(f'{MODULES_LIBRARY}/{module_name}/{DEFINITION_NAME}'):
            with open(f'{MODULES_LIBRARY}/{module_name}/{DEFINITION_NAME}') as definition_buffer:
                definition_lines = definition_buffer.readlines()
            for line in definition_lines:
                if line.strip().split(' = ')[0] == 'game':
                    if len(line.strip().split(' = ')) > 1:
                        if line.strip().split(' = ')[1] == game:
                            if return_type == 'names':
                                game_modules_list.append(module_name)
                            elif return_type == 'definitions':
                                game_modules_list.append(
                                    read_definition(module_path=f'{MODULES_LIBRARY}/{module_name}').copy()
                                )
        elif 'names' == return_type:
            if '-' in module_name:
                if module_name.split('-')[0] == game:
                    game_modules_list.append(module_name)
            elif '_' in module_name:
                if module_name.split('_')[0] == game:
                    game_modules_list.append(module_name)
    return game_modules_list


# 024-08-04
def analyse_modules(modules_names=None, check='definition', game=None):
    if modules_names is None:
        if game is None:
            modules_names = listdir(MODULES_LIBRARY)
        else:
            modules_names = modules_filter(game)
    if game is not None:
        modules_names = modules_filter(game)
    definition_status_dict = {}
    for module_name in modules_names:
        module_active = False
        version_directory = f'{MODULES_LIBRARY}/{module_name}'
        if check == 'definition':
            if path.exists(f"{version_directory}/{DEFINITION_NAME}"):
                with open(f"{version_directory}/{DEFINITION_NAME}") as definition_buffer:
                    definition_lines = definition_buffer.readlines()
                for line in definition_lines:
                    if 'active' in line and len(line.strip().split(' = ')) > 1:
                        value = line.strip().split(' = ')[1]
                        if value == 'True':
                            module_active = True
            else:
                module_active = None
        elif check == 'snapshot':
            if path.exists(f"{version_directory}/comparison_{module_name}.txt"):
                with open(f"{version_directory}/comparison_{module_name}.txt") as comparison_file:
                    comparison_lines = comparison_file.readlines()
                for line in comparison_lines:
                    file_path, value = line.strip().split('\t')
                    file_path_library = (
                        f'{version_directory}'
                        f"{file_path[len(settings['installation_path']):]}"
                    )  # file_path.index(settings['installation_path']) +
                    if path.exists(file_path) and not path.exists(file_path_library):
                        module_active = True
                    elif value != 'unchanged' and value != 'removed':
                        module_active = False
                        break
        definition_status_dict[module_name] = module_active
    return definition_status_dict


# def translate_comparison(comparison_file=None):
#     if comparison_file is None:
#         comparison_file = askopenfilename()
#     suppression_list = [
#         'O:/RotWK/202_launcher.exe',
#         'O:/RotWK/202_launcher_source.zip',
#         'O:/RotWK/asset.other',
#         'O:/RotWK/asset1.dat',
#         'O:/RotWK/asset2.dat',
#         'O:/RotWK/asset830c.dat',
#         'O:/RotWK/game.other',
#         'O:/RotWK/game820.dat',
#         'O:/RotWK/launcher202_log.txt',
#         'O:/RotWK/launcher_releases/2.01.ini',
#         'O:/RotWK/launcher_releases/2.02 music.ini',
#         'O:/RotWK/launcher_releases/2.02 v3.0.0.0.ini',
#         'O:/RotWK/launcher_releases/2.02 v3.0.0.1.ini',
#         'O:/RotWK/launcher_releases/2.02 v3.0.1.0.ini',
#         'O:/RotWK/launcher_releases/2.02 v3.0.1.1.ini',
#         'O:/RotWK/launcher_releases/2.02 v3.0.1.2.ini',
#         'O:/RotWK/launcher_releases/2.02 v3.0.2.0.ini',
#         'O:/RotWK/launcher_releases/2.02 v3.0.2.1.ini',
#         'O:/RotWK/launcher_releases/2.02 v3.0.2.2.ini',
#         'O:/RotWK/launcher_releases/2.02 v3.0.3.0.ini',
#         'O:/RotWK/launcher_releases/2.02 v3.0.3.1.ini',
#         'O:/RotWK/launcher_releases/2.02 v3.0.4.0.ini',
#         'O:/RotWK/launcher_releases/2.02 v3.0.5.0.ini',
#         'O:/RotWK/launcher_releases/2.02 v3.0.5.1.ini',
#         'O:/RotWK/launcher_releases/2.02 v3.0.5.2.ini',
#         'O:/RotWK/launcher_releases/2.02 v3.0.6.0.ini',
#         'O:/RotWK/launcher_releases/2.02 v3.6.1.ini',
#         'O:/RotWK/launcher_releases/2.02 v4.0.0.ini',
#         'O:/RotWK/launcher_releases/2.02 v5.0.0.ini',
#         'O:/RotWK/launcher_releases/2.02 v5.0.1.ini',
#         'O:/RotWK/launcher_releases/2.02 v6.0.0.ini',
#         'O:/RotWK/launcher_releases/2.02 v7.0.0.ini',
#         'O:/RotWK/launcher_releases/2.02 v8.0.0.ini',
#         'O:/RotWK/launcher_releases/2.02 v8.0.1.ini',
#         'O:/RotWK/launcher_releases/2.02 v8.2.0.ini',
#         'O:/RotWK/launcher_releases/2.02 v8.3.0.ini',
#         'O:/RotWK/launcher_releases/2.02 v8.4.0.ini',
#         'O:/RotWK/launcher_releases/2.02 v8.5.0.ini',
#         'O:/RotWK/launcher_releases/2.02 v9.0.0.ini',
#         'O:/RotWK/launcher_releases/Delayfix disable.ini',
#         'O:/RotWK/launcher_releases/Delayfix enable.ini',
#         'O:/RotWK/launcher_releases/Disable02.ini',
#         'O:/RotWK/launcher_releases/Intro movies disable.ini',
#         'O:/RotWK/launcher_releases/Intro movies enable.ini',
#         'O:/RotWK/launcher_releases/Minimal music.ini',
#         'O:/RotWK/launcher_releases/Timer disable.ini',
#         'O:/RotWK/launcher_releases/Timer enable.ini',
#         'O:/RotWK/lotrbfme2ep1v9.exe',
#         'O:/RotWK/Music202.big',
#         'O:/RotWK/patch.doc',
#         'O:/RotWK/uninstall02.exe'
#     ]
#     with open(comparison_file) as comparison_buffer:
#         comparison_lines = comparison_buffer.readlines()
#     new_content = ''
#     for line in comparison_lines:
#         full_path, tag = line.split('\t')
#         if full_path in suppression_list:
#             pass
#         elif full_path.split('.')[-1] == 'disabled':
#             pass
#         else:
#             new_content += line
#     os.rename(comparison_file, comparison_file.replace('.txt', '_enabler.txt'))
#     with open(comparison_file, 'w') as comparison_buffer:
#         comparison_buffer.write(new_content)
#     print('translate_comparison successful')


# 024-08-05
def draft_change_game_name(old_name, new_name, file_changed=None):
    if file_changed is None:
        file_changed = askopenfilename()
        if not file_changed:
            return
    if path.isfile(file_changed):
        old_game_name = f'/{old_name}/'
        new_game_name = f'/{new_name}/'
        new_content = ''
        with open(file_changed) as file_buffer:
            file_content = file_buffer.readlines()
        for line in file_content:
            new_content += line.replace(old_game_name, new_game_name)
        with open(file_changed, 'w') as file_buffer:
            file_buffer.write(new_content)


# 024-08-03
def draft_definition_initiator():
    version_names = listdir(MODULES_LIBRARY)
    for version_name in version_names:
        # if path.exists(f'{MODULES_LIBRARY}/{version_name}/{DEFINITION_NAME}'):
        #     os.remove(f'{MODULES_LIBRARY}/{version_name}/{DEFINITION_NAME}')
        version_ancestor, version_heir = '', ''
        if version_names.index(version_name) > 0:
            version_ancestor = version_names[version_names.index(version_name) - 1]
        if version_names.index(version_name) < len(version_names) + 1:
            version_heir = version_names[version_names.index(version_name) + 1]
        write_definition(module_directory=f'{MODULES_LIBRARY}/{version_name}', return_type='save',
                         ancestor=version_ancestor, heir=version_heir)


# snapshot_make(modules_paths=['RotWK'])  #
# snapshot_compare()
# translate_comparison()
TEST = False
# TEST = True
# module_attach()
# module_reverse(transfer='move')
# make_module(mod_name='AotR8-3')
# initiate_version_definition()
# draft_definition_initiator()
# draft_change_game_name(old_name='AotR', new_name='AotR8')


all_functions = [
    write_definition,
    read_definition,
    edit_definition,
    hash_file,
    hash_directory,
    get_last_snapshot_id,
    snapshot_make,
    snapshot_compare,
    test_transfer,
    ensure_path_exists,
    module_reverse,
    module_attach,
    module_copy,
    module_detect_changes,
    modules_filter,
    analyse_modules,
    draft_change_game_name,
    draft_definition_initiator
]
